{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends.js\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator/index.js\";\nimport React from 'react';\nimport StaticAxios from 'axios';\nimport LRU from 'lru-cache';\nvar actions = {\n  REQUEST_START: 'REQUEST_START',\n  REQUEST_END: 'REQUEST_END'\n};\nvar defaultUseAxios = makeUseAxios();\nvar __ssrPromises = defaultUseAxios.__ssrPromises,\n    resetConfigure = defaultUseAxios.resetConfigure,\n    configure = defaultUseAxios.configure,\n    loadCache = defaultUseAxios.loadCache,\n    serializeCache = defaultUseAxios.serializeCache;\nexport default defaultUseAxios;\nexport { __ssrPromises, resetConfigure, configure, loadCache, serializeCache };\nexport function makeUseAxios(configurationOptions) {\n  var cache;\n  var axiosInstance;\n  var __ssrPromises = [];\n\n  function resetConfigure() {\n    cache = new LRU();\n    axiosInstance = StaticAxios;\n  }\n\n  resetConfigure();\n\n  function configure(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (options.axios) {\n      axiosInstance = options.axios;\n    }\n\n    if (options.cache) {\n      cache = options.cache;\n    }\n  }\n\n  configure(configurationOptions);\n\n  function loadCache(data) {\n    cache.load(data);\n  }\n\n  function serializeCache() {\n    var ssrPromisesCopy;\n    return _regeneratorRuntime.async(function serializeCache$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ssrPromisesCopy = [].concat(__ssrPromises);\n            __ssrPromises.length = 0;\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(Promise.all(ssrPromisesCopy));\n\n          case 4:\n            return _context.abrupt(\"return\", cache.dump());\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  }\n\n  return Object.assign(useAxios, {\n    __ssrPromises: __ssrPromises,\n    resetConfigure: resetConfigure,\n    configure: configure,\n    loadCache: loadCache,\n    serializeCache: serializeCache\n  });\n\n  function cacheAdapter(config) {\n    var cacheKey, hit, response, responseForCache;\n    return _regeneratorRuntime.async(function cacheAdapter$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cacheKey = JSON.stringify(config);\n            hit = cache.get(cacheKey);\n\n            if (!hit) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", hit);\n\n          case 4:\n            delete config.adapter;\n            _context2.next = 7;\n            return _regeneratorRuntime.awrap(axiosInstance(config));\n\n          case 7:\n            response = _context2.sent;\n            responseForCache = _extends({}, response);\n            delete responseForCache.config;\n            delete responseForCache.request;\n            cache.set(cacheKey, responseForCache);\n            return _context2.abrupt(\"return\", response);\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  }\n\n  function createInitialState(options) {\n    return {\n      loading: !options.manual\n    };\n  }\n\n  function reducer(state, action) {\n    var _extends2;\n\n    switch (action.type) {\n      case actions.REQUEST_START:\n        return _extends({}, state, {\n          loading: true,\n          error: null\n        });\n\n      case actions.REQUEST_END:\n        return _extends({}, state, {\n          loading: false\n        }, action.error ? {} : {\n          data: action.payload.data\n        }, (_extends2 = {}, _extends2[action.error ? 'error' : 'response'] = action.payload, _extends2));\n\n      default:\n        return state;\n    }\n  }\n\n  function request(config, dispatch) {\n    var response;\n    return _regeneratorRuntime.async(function request$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            dispatch({\n              type: actions.REQUEST_START\n            });\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(axiosInstance(config));\n\n          case 4:\n            response = _context3.sent;\n            dispatch({\n              type: actions.REQUEST_END,\n              payload: response\n            });\n            return _context3.abrupt(\"return\", response);\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3[\"catch\"](0);\n\n            if (!StaticAxios.isCancel(_context3.t0)) {\n              _context3.next = 13;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 13:\n            dispatch({\n              type: actions.REQUEST_END,\n              payload: _context3.t0,\n              error: true\n            });\n            throw _context3.t0;\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 9]]);\n  }\n\n  function executeRequestWithCache(config, dispatch) {\n    return request(_extends({}, config, {\n      adapter: cacheAdapter\n    }), dispatch);\n  }\n\n  function executeRequestWithoutCache(config, dispatch) {\n    return request(config, dispatch);\n  }\n\n  function executeRequest(config, options, dispatch) {\n    if (options.useCache) {\n      return executeRequestWithCache(config, dispatch);\n    }\n\n    return executeRequestWithoutCache(config, dispatch);\n  }\n\n  function useAxios(config, options) {\n    if (typeof config === 'string') {\n      config = {\n        url: config\n      };\n    }\n\n    var stringifiedConfig = JSON.stringify(config);\n    options = _extends({\n      manual: false,\n      useCache: true\n    }, options);\n    var cancelSourceRef = React.useRef();\n\n    var _React$useReducer = React.useReducer(reducer, createInitialState(options)),\n        state = _React$useReducer[0],\n        dispatch = _React$useReducer[1];\n\n    if (typeof window === 'undefined' && !options.manual) {\n      useAxios.__ssrPromises.push(axiosInstance(_extends({}, config, {\n        adapter: cacheAdapter\n      })));\n    }\n\n    React.useEffect(function () {\n      cancelSourceRef.current = StaticAxios.CancelToken.source();\n\n      if (!options.manual) {\n        executeRequest(_extends({\n          cancelToken: cancelSourceRef.current.token\n        }, config), options, dispatch)[\"catch\"](function () {});\n      }\n\n      return function () {\n        return cancelSourceRef.current.cancel();\n      }; // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [stringifiedConfig]);\n    var refetch = React.useCallback(function (configOverride, options) {\n      return executeRequest(_extends({\n        cancelToken: cancelSourceRef.current.token\n      }, config, {}, configOverride), _extends({\n        useCache: false\n      }, options), dispatch);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [stringifiedConfig]);\n    return [state, refetch];\n  }\n}","map":null,"metadata":{},"sourceType":"module"}